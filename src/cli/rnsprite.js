"use strict"

const Spritesmith = require('spritesmith');
const fs = require('fs');
const path = require('path');
const events = require('events');
const { promisify } = require('util');
const { Project, SyntaxKind } = require('ts-morph');

// Spritesmith setup
const spritesmith = new Spritesmith();
const createImagesAsync = promisify(spritesmith.createImages.bind(spritesmith));

// ts-morph setup
const tsMorphProj = new Project();
const hookSource = tsMorphProj.addSourceFileAtPath(path.join(__dirname, "..", "useSpriteSheet.tsx"));

const writeStream = (istream, path, opts = {}) => {
    return new Promise(async (resolve, reject) => {
        const ostream = fs.createWriteStream(path, opts);
        istream.pipe(ostream);
        ostream.on('error', reject);
        istream.on('error', reject);
        await events.once(ostream, 'finish');
        resolve();
    });
};


const main = async () => {
    if (process.argv.length != 4) {
        console.error(
            `FAIL: Your react-native-sprite-sheets script line in package.json is invalid. It should be:
rnsprite (source path) (output path) as described in the docs`);
        process.exit(1);
    }

    const src = process.argv[2];
    const out = process.argv[3];

    if (!fs.existsSync(src)) {
        console.error("FAIL: source directory does not exist. Check your react-native-sprite-sheets script line in package.json");
        process.exit(1);
    }

    if (fs.readdirSync(src).length == 0) {
        console.error("FAIL: no icons to compile");
        process.exit(1);
    }

    let jobs = {};

    // Validate everything and split into jobs
    for (let spriteSheetDirInputName of fs.readdirSync(src)) {
        let spriteSheetDirInputPath = path.join(src, spriteSheetDirInputName);
        if (!fs.statSync(spriteSheetDirInputPath).isDirectory) {
            console.error(`FAIL: sprite sheet ${spriteSheetDirInputPath} is not a directory`);
            process.exit(1);
        }

        let filesInSheetNames = fs.readdirSync(spriteSheetDirInputPath);
        let filesInSheetPaths = filesInSheetNames.map(fileInSheetName => path.join(spriteSheetDirInputPath, fileInSheetName));

        if (filesInSheetPaths.some(fileInSheetPath => fs.statSync(fileInSheetPath).isDirectory())) {
            console.error("FAIL: sprite sheet " + spriteSheetDirInputName + " contains directories");
            process.exit(1);
        }

        jobs[spriteSheetDirInputName + ".png"] = filesInSheetPaths;
    }

    if (!fs.existsSync(out)) fs.mkdirSync(out, true);

    const existingOutFiles = fs.readdirSync(out);
    if (existingOutFiles.length > 0) {
        if (existingOutFiles.some(file => !file.endsWith(".png") && !file.endsWith(".json") && file != "README.txt" && file != "useSpriteSheet.tsx")) {
            console.error("FAIL: output directory contains files that could not have been created by rnsprite. Refusing to clean up automatically. Try deleting the output directory contents manually");
            process.exit(1);
        }
        console.log("Output directory not clean. Cleaning");
        existingOutFiles.forEach(existingOutFile => fs.rmSync(path.join(out, existingOutFile)));
    }

    fs.writeFileSync(path.join(out, "README.txt"),
        `This directory is generated automatically by react-native-sprite-sheets.
Any modifications made to this directory will be overriden next time the sprite sheets are compiled.
Instead, modify the sprite inputs and rerun your rnsprite:pack script as documented at https://github.com/GNUGradyn/react-native-sprite-sheets`);

    for (let i = 0; i < Object.keys(jobs).length; i++) {
        const jobkey = Object.keys(jobs)[i];
        const job = jobs[jobkey];

        console.log(`Processing sprite sheet ${jobkey} (job ${i + 1} of ${Object.keys(jobs).length})`);

        const spriteSheetImgOutputPath = path.join(out, jobkey);

        const images = await createImagesAsync(job);
        const result = spritesmith.processImages(images);

        await writeStream(result.image, spriteSheetImgOutputPath);

        const coordinates = Object.fromEntries(
            Object.entries(result.coordinates)
                .map(([k, v]) => [path.basename(k), v])
        );
        fs.writeFileSync(spriteSheetImgOutputPath + ".json", JSON.stringify(coordinates), 'utf8');
    }

    console.log("Generating hook source code");
    // Replace comment at the top
    hookSource.getStatementsWithComments()[0].replaceWithText("// This file was auto generated by react-native-sprite-sheets. Do not modify it as any changes will be lost when the sprite sheet is recompiled")
    // Add assets
    const assetsVarDecl = hookSource.getVariableDeclaration("spriteSheetAssets");
    const assetsVarObjLit = assetsVarDecl.getInitializerIfKindOrThrow(SyntaxKind.ObjectLiteralExpression);
    Object.keys(jobs).forEach(jobKey =>
        assetsVarObjLit.addPropertyAssignment({
            name: jobKey.slice(0, -4), // Remove .png suffix
            initializer: `{ image: require("./${jobKey}"), map: require("./${jobKey}.json") }`
        })
    );
    const hookOutput = hookSource.copy(path.join(path.resolve(out), "useSpriteSheet.tsx"));
    await hookOutput.save();

    console.log("Spritesheets recompiled");
}

main();